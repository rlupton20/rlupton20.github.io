<!doctype html><html lang=en-us><head><title>Pure Hack - Object Models, Threading Models and Actor Models</title><link rel=stylesheet href=https://rlupton20.github.io/css/style.css><meta name=viewport content="width=device-width,initial-scale=1"></head><body><div id=header><a class=site-title href=https://rlupton20.github.io/>Pure Hack</a></div><div id=content><h1 class=title>Object Models, Threading Models and Actor Models</h1><p>One of the often recognized issues with object-oriented programming is that it&rsquo;s often hard to write multithreaded software well. Why should this be the case?</p><p>One of the core principles of object-oriented programming is that objects own the state which they manage internally.
Objects present an API which can maintain a set of internal invariants. Methods on the object mutate state to ensure these invariants are upheld.
On a single threaded system this seems a tenable idea<sup class=footnote-ref id=fnref:1><a href=#fn:1>1</a></sup> - mutations are easy to sequence when only one thing happens at a time.</p><p>When two threads are involved the picture changes.
What matters in the multithreaded world is where the instruction pointers go on the individual threads.
Without exclusion, there is nothing to stop two threads executing method calls on an individual object at the same time, either because the two threads are running on different cores, or one thread got pre-empted part way through the execution of a method.
For methods which access (globally) read-only data this doesn&rsquo;t cause any issues.
As soon as we introduce mutation, we need either a way to sequence operations to keep the object consistent, or to use a lock and exclude concurrent access.</p><p>In other words, thread ownership must dominate object ownership.</p><p>Enforcing sequential access to data really limits the amount of concurrency we can achieve, and often can leave threads spinning or blocked, and not making progress.
It&rsquo;s not just that only one thread can operate on the data at any one time.
If a piece of data is read and written from two cores (for arguments sake, on the same socket, since non-uniform memory access only exacerbates these issues), then each write must be pushed out to L3 cache (L2 on older architectures) for the other core to see it.
This reduces the number of concurrent data accesses we can make in a fixed time period when 2 cores are trying to make progress, because the cost of a write increases about 10x. The key thing here is that this blocks other work from being done (in practice this is usually an <code>mfence</code> instruction).</p><p>Suppose we wanted to avoid that cost.
Object method execution would then have to be pinned to a single core.
But then how do objects communicate across cores?
We can&rsquo;t just call methods because then we start executing a foreign core&rsquo;s object methods on the wrong core.
The natural thing to do is to introduce queues, and have objects read messages and dispatch data to each other asynchronously on these queues. If our queues are single-producer-single-consumer then we don&rsquo;t need full sequential consistency, and can manage with release semantics on writes and acquire semantics on read, which is already guaranteed on regular writes and reads in the x86_64 instruction set anyway (these semantics place guarantees on the order on which memory changes are observed, but not when).</p><p>Note that the data must go via L3 cache still, but that happens asynchronously, and the core won&rsquo;t be waiting for the synchronization to happen (that is, for a memory fence instruction to do its work) and can progress with something else</p><p>At that point method calls are redundant, and our objects are actually just loops acting on data arriving in queues<sup class=footnote-ref id=fnref:2><a href=#fn:2>2</a></sup>.
What we really have is a small actor model.</p><p>The differences here shouldn&rsquo;t be understated.
Passing messages is very different from making method calls.
To begin with asynchronous message passing provides no illusions of global temporal consistency - with multi-threaded code the system can appear to be in different states at different times in different places, and what matters is often what order things are observed in localised to one core.
Note that the ordering of observations is often not globally consistent, and is localised to individual cores.</p><p>At this point focusing on objects is just an unnecessary distraction.</p><div class=footnotes><hr><ol><li id=fn:1>And yet these systems still end up a total mess.
<a class=footnote-return href=#fnref:1><sup>[return]</sup></a></li><li id=fn:2>I&rsquo;m not claiming this model is optimal and devoid of issues, or even fast, it&rsquo;s just a natural consequence of not wanting to pay the full price of a memory fence every read/write.
<a class=footnote-return href=#fnref:2><sup>[return]</sup></a></li></ol></div></div><div id=footer><a href=https://github.com/rlupton20><img class=nav-icon src=https://rlupton20.github.io/icons/github.svg></a></div></body></html>