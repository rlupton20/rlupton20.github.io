<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Pure Hack</title><link>https://rlupton20.github.io/</link><description>Recent content on Pure Hack</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 05 Jun 2020 22:49:49 +0000</lastBuildDate><atom:link href="https://rlupton20.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Some thoughts on BSD</title><link>https://rlupton20.github.io/posts/openbsd-some-thoughts/</link><pubDate>Fri, 05 Jun 2020 22:49:49 +0000</pubDate><guid>https://rlupton20.github.io/posts/openbsd-some-thoughts/</guid><description>I&amp;rsquo;ve played with BSD on and off over the course of the last few years. I initially messed around with DragonflyBSD for a while, and enjoyed the process (in part because some hackery was required to get it working in my arrangement), and was impressed by how useful the documentation was (in particular, man pages).
After acquiring a Thinkpad x200s for little money, I thought it might be interesting to give OpenBSD a shot.</description></item><item><title>Object Models, Threading Models and Actor Models</title><link>https://rlupton20.github.io/posts/object-threading-models/</link><pubDate>Sun, 24 May 2020 14:50:15 +0000</pubDate><guid>https://rlupton20.github.io/posts/object-threading-models/</guid><description>One of the often recognized issues with object-oriented programming is that it&amp;rsquo;s often hard to write multithreaded software well. Why should this be the case?
One of the core principles of object-oriented programming is that objects own the state which they manage internally. Objects present an API which can maintain a set of internal invariants. Methods on the object mutate state to ensure these invariants are upheld. On a single threaded system this seems a tenable idea1 - mutations are easy to sequence when only one thing happens at a time.</description></item><item><title>Structural Clarity</title><link>https://rlupton20.github.io/posts/structural-clarity/</link><pubDate>Mon, 04 May 2020 19:55:55 +0000</pubDate><guid>https://rlupton20.github.io/posts/structural-clarity/</guid><description>There is a trend in software engineering to conflate &amp;ldquo;good code&amp;rdquo; with making it read like English (or your native language of choice). It&amp;rsquo;s not obvious that this is a valuable thing to aim for. Indeed, working hard to make code read like English is often pointless, or even counterproductive, in a variety of situations.
To begin with, English is very imprecise, a quality computers don&amp;rsquo;t grant much tolerance for. Clarity and precision is often not a function of how the code &amp;ldquo;reads&amp;rdquo;, but of the core structure and invariants that bind it together1.</description></item><item><title>Easy, reproducible, and shareable development environments</title><link>https://rlupton20.github.io/posts/floki/</link><pubDate>Wed, 18 Mar 2020 19:32:29 +0000</pubDate><guid>https://rlupton20.github.io/posts/floki/</guid><description>Docker makes it easy to create container images containing the tools you need to work on a project. However this can be fiddly to use well in many circumstances. Here we will visit the normal approach of using a docker container for development environments, indicate some ways in which it gets complicated, and then introduce a solution, called floki which greases the wheels and makes the whole process easier.</description></item><item><title>Overloaded Labels in Haskell - towards better record fields</title><link>https://rlupton20.github.io/posts/overloaded-labels-in-haskell/</link><pubDate>Sun, 29 Dec 2019 20:19:09 +0000</pubDate><guid>https://rlupton20.github.io/posts/overloaded-labels-in-haskell/</guid><description>Introduction Haskell is one of my (if not my) favourite language. Like all languages it has its warts, and one which I have always found particularly annoying is the fact that record names of data types can&amp;rsquo;t be overloaded (they are just functions, after all). I haven&amp;rsquo;t been writing as much Haskell as I would like lately, and certainly haven&amp;rsquo;t been messing around with the more cutting edge type level functionality, but noticed that GHC 8.</description></item><item><title>Getting Started With ST - the simple terminal</title><link>https://rlupton20.github.io/posts/getting-started-with-st/</link><pubDate>Thu, 26 Dec 2019 18:35:10 +0000</pubDate><guid>https://rlupton20.github.io/posts/getting-started-with-st/</guid><description>Introduction st is a simple terminal emulator from suckless tools. It provides the core features you need from a virtual terminal without being a bloated mess. While I like urxvt, st is smaller, simpler and a touch faster. Like most suckless tools, st provides a minimal feature set, with the expectation that users will patch in additional features as wanted, or compose st with other tools (e.g. dmenu) to provide a more complex experience.</description></item><item><title>Getting decent font rendering on stock Debian</title><link>https://rlupton20.github.io/posts/debian-font-configuration/</link><pubDate>Tue, 19 Nov 2019 00:26:54 +0000</pubDate><guid>https://rlupton20.github.io/posts/debian-font-configuration/</guid><description>I recently converted one of my machines from a parabola installation to a Debian 10 system. I started from a text only interface - the bare minimum of packages - and installed the rest by hand. For reasons that aren&amp;rsquo;t entirely clear, the default font rendering is pretty hideous. It took me a while to track down how to properly configure font rendering. Perhaps this isn&amp;rsquo;t an issue for installs which include a desktop from the get go.</description></item><item><title>The Y combinator - understanding recursion without recursion</title><link>https://rlupton20.github.io/posts/y-combinator/</link><pubDate>Wed, 30 Oct 2019 12:21:36 +0000</pubDate><guid>https://rlupton20.github.io/posts/y-combinator/</guid><description>Introduction Recursion is central to functional programming, as a clearer alternative to loops as other control structures typical of imperative languages. Functional programming encourages programmers to study recursion in greater depths. I first encountered the Y combinator in the mind-bending penultimate chapter of the wonderful The Little Schemer, which explores recursion in great depth. In an effort to unbend my own mind on the subject, I decided to derive it for myself, so I could see how it worked, and gain an extra tool in dealing with recursion and closures.</description></item><item><title>Libre-rate your NixOS</title><link>https://rlupton20.github.io/posts/2017-09-25-libre-rate-your-nixos/</link><pubDate>Mon, 25 Sep 2017 16:00:00 +0000</pubDate><guid>https://rlupton20.github.io/posts/2017-09-25-libre-rate-your-nixos/</guid><description>NixOS isn&amp;rsquo;t a libre distribution by any means, but it comes close, and maintains a clear distinction between free and non-free packages (and in fact, different license types). This makes it possible to configure the system to exclude non-free packages, and with the addition of a libre kernel, allows us to turn NixOS into a libre platform. Of course, this isn&amp;rsquo;t the same as leveraging an FSF endorsed distribution, but for those who are happy to maintain and take responsibility for the software running on their systems, it&amp;rsquo;s as good.</description></item><item><title>Booting DragonFly BSD with HAMMER on a GPT drive</title><link>https://rlupton20.github.io/posts/2015-10-23-booting-dragonfly-bsd-on-a-gpt-drive/</link><pubDate>Fri, 23 Oct 2015 16:00:00 +0000</pubDate><guid>https://rlupton20.github.io/posts/2015-10-23-booting-dragonfly-bsd-on-a-gpt-drive/</guid><description>Here I’ll outline how I managed to get DragonFly BSD to boot from a single slice (Linux: partition) by chainloading the DragonFly bootloader boot1.
Note: for clarity’s sake, I’ll stick to the BSD terminology here. Slice refers to what Linux would dub a partition, and partition refers to a Linux “partition of a partition”. Linux’s sda1 would therefore be slice 0 of disk sda (BSD counts from 0), which on my BSD system is denoted da0s0 (disk 0 slice 0 – first disk first slice).</description></item></channel></rss>