<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Pure Hack</title><link>https://rlupton20.github.io/</link><description>Recent content on Pure Hack</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 18 Mar 2020 19:32:29 +0000</lastBuildDate><atom:link href="https://rlupton20.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Easy, reproducible, and shareable development environments</title><link>https://rlupton20.github.io/posts/floki/</link><pubDate>Wed, 18 Mar 2020 19:32:29 +0000</pubDate><guid>https://rlupton20.github.io/posts/floki/</guid><description>Docker makes it easy to create container images containing the tools you need to work on a project. However this can be fiddly to use well in many circumstances. Here we will visit the normal approach of using a docker container for development environments, indicate some ways in which it gets complicated, and then introduce a solution, called floki which greases the wheels and makes the whole process easier.</description></item><item><title>Overloaded Labels in Haskell - towards better record fields</title><link>https://rlupton20.github.io/posts/overloaded-labels-in-haskell/</link><pubDate>Sun, 29 Dec 2019 20:19:09 +0000</pubDate><guid>https://rlupton20.github.io/posts/overloaded-labels-in-haskell/</guid><description>Introduction Haskell is one of my (if not my) favourite language. Like all languages it has its warts, and one which I have always found particularly annoying is the fact that record names of data types can&amp;rsquo;t be overloaded (they are just functions, after all). I haven&amp;rsquo;t been writing as much Haskell as I would like lately, and certainly haven&amp;rsquo;t been messing around with the more cutting edge type level functionality, but noticed that GHC 8.</description></item><item><title>Getting Started With ST - the simple terminal</title><link>https://rlupton20.github.io/posts/getting-started-with-st/</link><pubDate>Thu, 26 Dec 2019 18:35:10 +0000</pubDate><guid>https://rlupton20.github.io/posts/getting-started-with-st/</guid><description>Introduction st is a simple terminal emulator from suckless tools. It provides the core features you need from a virtual terminal without being a bloated mess. While I like urxvt, st is smaller, simpler and a touch faster. Like most suckless tools, st provides a minimal feature set, with the expectation that users will patch in additional features as wanted, or compose st with other tools (e.g. dmenu) to provide a more complex experience.</description></item><item><title>Getting decent font rendering on stock Debian</title><link>https://rlupton20.github.io/posts/debian-font-configuration/</link><pubDate>Tue, 19 Nov 2019 00:26:54 +0000</pubDate><guid>https://rlupton20.github.io/posts/debian-font-configuration/</guid><description>I recently converted one of my machines from a parabola installation to a Debian 10 system. I started from a text only interface - the bare minimum of packages - and installed the rest by hand. For reasons that aren&amp;rsquo;t entirely clear, the default font rendering is pretty hideous. It took me a while to track down how to properly configure font rendering. Perhaps this isn&amp;rsquo;t an issue for installs which include a desktop from the get go.</description></item><item><title>The Y combinator - understanding recursion without recursion</title><link>https://rlupton20.github.io/posts/y-combinator/</link><pubDate>Wed, 30 Oct 2019 12:21:36 +0000</pubDate><guid>https://rlupton20.github.io/posts/y-combinator/</guid><description>Introduction Recursion is central to functional programming, as a clearer alternative to loops as other control structures typical of imperative languages. Functional programming encourages programmers to study recursion in greater depths. I first encountered the Y combinator in the mind-bending penultimate chapter of the wonderful The Little Schemer, which explores recursion in great depth. In an effort to unbend my own mind on the subject, I decided to derive it for myself, so I could see how it worked, and gain an extra tool in dealing with recursion and closures.</description></item><item><title>Libre-rate your NixOS</title><link>https://rlupton20.github.io/posts/2017-09-25-libre-rate-your-nixos/</link><pubDate>Mon, 25 Sep 2017 16:00:00 +0000</pubDate><guid>https://rlupton20.github.io/posts/2017-09-25-libre-rate-your-nixos/</guid><description>NixOS isn&amp;rsquo;t a libre distribution by any means, but it comes close, and maintains a clear distinction between free and non-free packages (and in fact, different license types). This makes it possible to configure the system to exclude non-free packages, and with the addition of a libre kernel, allows us to turn NixOS into a libre platform. Of course, this isn&amp;rsquo;t the same as leveraging an FSF endorsed distribution, but for those who are happy to maintain and take responsibility for the software running on their systems, it&amp;rsquo;s as good.</description></item><item><title>Booting DragonFly BSD with HAMMER on a GPT drive</title><link>https://rlupton20.github.io/posts/2015-10-23-booting-dragonfly-bsd-on-a-gpt-drive/</link><pubDate>Fri, 23 Oct 2015 16:00:00 +0000</pubDate><guid>https://rlupton20.github.io/posts/2015-10-23-booting-dragonfly-bsd-on-a-gpt-drive/</guid><description>Here I’ll outline how I managed to get DragonFly BSD to boot from a single slice (Linux: partition) by chainloading the DragonFly bootloader boot1.
Note: for clarity’s sake, I’ll stick to the BSD terminology here. Slice refers to what Linux would dub a partition, and partition refers to a Linux “partition of a partition”. Linux’s sda1 would therefore be slice 0 of disk sda (BSD counts from 0), which on my BSD system is denoted da0s0 (disk 0 slice 0 – first disk first slice).</description></item></channel></rss>