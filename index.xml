<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Pure Hack</title><link>https://rlupton20.github.io/</link><description>Recent content on Pure Hack</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 19 Nov 2019 00:26:54 +0000</lastBuildDate><atom:link href="https://rlupton20.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Getting decent font rendering on stock Debian</title><link>https://rlupton20.github.io/posts/debian-font-configuration/</link><pubDate>Tue, 19 Nov 2019 00:26:54 +0000</pubDate><guid>https://rlupton20.github.io/posts/debian-font-configuration/</guid><description>I recently converted one of my machines from a parabola installation to a Debian 10 system. I started from a text only interface - the bare minimum of packages - and installed the rest by hand. For reasons that aren&amp;rsquo;t entirely clear, the default font rendering is pretty hideous. It took me a while to track down how to properly configure font rendering. Perhaps this isn&amp;rsquo;t an issue for installs which include a desktop from the get go.</description></item><item><title>The Y combinator - understanding recursion without recursion</title><link>https://rlupton20.github.io/posts/y-combinator/</link><pubDate>Wed, 30 Oct 2019 12:21:36 +0000</pubDate><guid>https://rlupton20.github.io/posts/y-combinator/</guid><description>Introduction Recursion is central to functional programming, as a clearer alternative to loops as other control structures typical of imperative languages. Functional programming encourages programmers to study recursion in greater depths. I first encountered the Y combinator in the mind-bending penultimate chapter of the wonderful The Little Schemer, which explores recursion in great depth. In an effort to unbend my own mind on the subject, I decided to derive it for myself, so I could see how it worked, and gain an extra tool in dealing with recursion and closures.</description></item><item><title>Libre-rate your NixOS</title><link>https://rlupton20.github.io/posts/2017-09-25-libre-rate-your-nixos/</link><pubDate>Mon, 25 Sep 2017 16:00:00 +0000</pubDate><guid>https://rlupton20.github.io/posts/2017-09-25-libre-rate-your-nixos/</guid><description>NixOS isn&amp;rsquo;t a libre distribution by any means, but it comes close, and maintains a clear distinction between free and non-free packages (and in fact, different license types). This makes it possible to configure the system to exclude non-free packages, and with the addition of a libre kernel, allows us to turn NixOS into a libre platform. Of course, this isn&amp;rsquo;t the same as leveraging an FSF endorsed distribution, but for those who are happy to maintain and take responsibility for the software running on their systems, it&amp;rsquo;s as good.</description></item><item><title>Lightweight screenshots in Xmonad</title><link>https://rlupton20.github.io/posts/2017-09-11-lightweight-screenshots-in-xmonad/</link><pubDate>Mon, 11 Sep 2017 16:00:00 +0000</pubDate><guid>https://rlupton20.github.io/posts/2017-09-11-lightweight-screenshots-in-xmonad/</guid><description>Introduction Xmonad does not come with any kind of screenshot tool (or anything at all much, which in my view is a good thing - what it does do it does well). I didn&amp;rsquo;t want a heavyweight system (something taken from GNOME or XFCE), but wanted some flexibility still. I made a little script which straps together rofi, slop, maim and xclip to provide a lightweight and flexible screenshotting tool.</description></item><item><title>Booting DragonFly BSD with HAMMER on a GPT drive</title><link>https://rlupton20.github.io/posts/2015-10-23-booting-dragonfly-bsd-on-a-gpt-drive/</link><pubDate>Fri, 23 Oct 2015 16:00:00 +0000</pubDate><guid>https://rlupton20.github.io/posts/2015-10-23-booting-dragonfly-bsd-on-a-gpt-drive/</guid><description>Here I’ll outline how I managed to get DragonFly BSD to boot from a single slice (Linux: partition) by chainloading the DragonFly bootloader boot1.
Note: for clarity’s sake, I’ll stick to the BSD terminology here. Slice refers to what Linux would dub a partition, and partition refers to a Linux “partition of a partition”. Linux’s sda1 would therefore be slice 0 of disk sda (BSD counts from 0), which on my BSD system is denoted da0s0 (disk 0 slice 0 – first disk first slice).</description></item></channel></rss>